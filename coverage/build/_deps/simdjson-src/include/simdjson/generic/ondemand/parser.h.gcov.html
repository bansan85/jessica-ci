<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage2.info - build/_deps/simdjson-src/include/simdjson/generic/ondemand/parser.h</title>
  <link rel="stylesheet" type="text/css" href="../../../../../../../gcov.css">
</head>

<body>

          <table width="100%" border=0 cellspacing=0 cellpadding=0>
            <tr><td class="title">LCOV - code coverage report</td></tr>
            <tr><td class="ruler"><img src="../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>

            <tr>
              <td width="100%">
                <table cellpadding=1 border=0 width="100%">
          <tr>
            <td class="headerItem" width="10%">Current view:</td>
            <td class="headerValue" width="10%"><a href="../../../../../../../index.html">top level</a> - <a href="index.html">build/_deps/simdjson-src/include/simdjson/generic/ondemand</a> - parser.h<span style="font-size: 80%;"> (source / <a href="parser.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="5%"></td>
            <td width="5%" class="headerCovTableHead">Coverage</td>
            <td class="headerCovTableHead" title="Covered + Uncovered code" width="5%">Total</td>
            <td width="5%" title="Exercised code only" class="headerCovTableHead">Hit</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage2.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntryHi">100.0&nbsp;%</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntry">1</td>
          </tr>
          <tr>
            <td class="headerItem">Test Date:</td>
            <td class="headerValue></td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntryHi">100.0&nbsp;%</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntry">1</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
            | Branches:
            <span class="coverLegendCov">+</span> taken
            <span class="coverLegendNoCov">-</span> not taken
            <span class="coverLegendNoCov">#</span> not executed
</td>
            <td></td>
            <td class="headerItem">Branches:</td>
            <td class="headerCovTableEntryHi">-</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">0</td>
          </tr>
                  <tr><td><img src="../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
                </table>
              </td>
            </tr>

            <tr><td class="ruler"><img src="../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
          </table>

          <table cellpadding=0 cellspacing=0 border=0>
            <tr>
              <td><br></td>
            </tr>
            <tr>
              <td>
<pre class="sourceHeading">             Branch data     Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1</span>                 :             : #include &quot;simdjson/error.h&quot;</a>
<a name="2"><span class="lineNum">       2</span>                 :             : </a>
<a name="3"><span class="lineNum">       3</span>                 :             : namespace simdjson {</a>
<a name="4"><span class="lineNum">       4</span>                 :             : namespace SIMDJSON_IMPLEMENTATION {</a>
<a name="5"><span class="lineNum">       5</span>                 :             : namespace ondemand {</a>
<a name="6"><span class="lineNum">       6</span>                 :             : </a>
<a name="7"><span class="lineNum">       7</span>                 :             : class array;</a>
<a name="8"><span class="lineNum">       8</span>                 :             : class object;</a>
<a name="9"><span class="lineNum">       9</span>                 :             : class value;</a>
<a name="10"><span class="lineNum">      10</span>                 :             : class raw_json_string;</a>
<a name="11"><span class="lineNum">      11</span>                 :             : class document_stream;</a>
<a name="12"><span class="lineNum">      12</span>                 :             : </a>
<a name="13"><span class="lineNum">      13</span>                 :             : /**</a>
<a name="14"><span class="lineNum">      14</span>                 :             :  * The default batch size for document_stream instances for this On Demand kernel.</a>
<a name="15"><span class="lineNum">      15</span>                 :             :  * Note that different On Demand kernel may use a different DEFAULT_BATCH_SIZE value</a>
<a name="16"><span class="lineNum">      16</span>                 :             :  * in the future.</a>
<a name="17"><span class="lineNum">      17</span>                 :             :  */</a>
<a name="18"><span class="lineNum">      18</span>                 :             : static constexpr size_t DEFAULT_BATCH_SIZE = 1000000;</a>
<a name="19"><span class="lineNum">      19</span>                 :             : /**</a>
<a name="20"><span class="lineNum">      20</span>                 :             :  * Some adversary might try to set the batch size to 0 or 1, which might cause problems.</a>
<a name="21"><span class="lineNum">      21</span>                 :             :  * We set a minimum of 32B since anything else is highly likely to be an error. In practice,</a>
<a name="22"><span class="lineNum">      22</span>                 :             :  * most users will want a much larger batch size.</a>
<a name="23"><span class="lineNum">      23</span>                 :             :  *</a>
<a name="24"><span class="lineNum">      24</span>                 :             :  * All non-negative MINIMAL_BATCH_SIZE values should be 'safe' except that, obviously, no JSON</a>
<a name="25"><span class="lineNum">      25</span>                 :             :  * document can ever span 0 or 1 byte and that very large values would create memory allocation issues.</a>
<a name="26"><span class="lineNum">      26</span>                 :             :  */</a>
<a name="27"><span class="lineNum">      27</span>                 :             : static constexpr size_t MINIMAL_BATCH_SIZE = 32;</a>
<a name="28"><span class="lineNum">      28</span>                 :             : </a>
<a name="29"><span class="lineNum">      29</span>                 :             : /**</a>
<a name="30"><span class="lineNum">      30</span>                 :             :  * A JSON fragment iterator.</a>
<a name="31"><span class="lineNum">      31</span>                 :             :  *</a>
<a name="32"><span class="lineNum">      32</span>                 :             :  * This holds the actual iterator as well as the buffer for writing strings.</a>
<a name="33"><span class="lineNum">      33</span>                 :             :  */</a>
<a name="34"><span class="lineNum">      34</span>                 :             : class parser {</a>
<a name="35"><span class="lineNum">      35</span>                 :             : public:</a>
<a name="36"><span class="lineNum">      36</span>                 :             :   /**</a>
<a name="37"><span class="lineNum">      37</span>                 :             :    * Create a JSON parser.</a>
<a name="38"><span class="lineNum">      38</span>                 :             :    *</a>
<a name="39"><span class="lineNum">      39</span>                 :             :    * The new parser will have zero capacity.</a>
<a name="40"><span class="lineNum">      40</span>                 :             :    */</a>
<a name="41"><span class="lineNum">      41</span>                 :             :   inline explicit parser(size_t max_capacity = SIMDJSON_MAXSIZE_BYTES) noexcept;</a>
<a name="42"><span class="lineNum">      42</span>                 :             : </a>
<a name="43"><span class="lineNum">      43</span>                 :             :   inline parser(parser &amp;&amp;other) noexcept = default;</a>
<a name="44"><span class="lineNum">      44</span>                 :             :   simdjson_really_inline parser(const parser &amp;other) = delete;</a>
<a name="45"><span class="lineNum">      45</span>                 :             :   simdjson_really_inline parser &amp;operator=(const parser &amp;other) = delete;</a>
<a name="46"><span class="lineNum">      46</span>                 :             :   simdjson_really_inline parser &amp;operator=(parser &amp;&amp;other) noexcept = default;</a>
<a name="47"><span class="lineNum">      47</span>                 :             : </a>
<a name="48"><span class="lineNum">      48</span>                 :             :   /** Deallocate the JSON parser. */</a>
<a name="49"><span class="lineNum">      49</span>                 :<span class="tlaGNC">           7 :   inline ~parser() noexcept = default;</span></a>
<a name="50"><span class="lineNum">      50</span>                 :             : </a>
<a name="51"><span class="lineNum">      51</span>                 :             :   /**</a>
<a name="52"><span class="lineNum">      52</span>                 :             :    * Start iterating an on-demand JSON document.</a>
<a name="53"><span class="lineNum">      53</span>                 :             :    *</a>
<a name="54"><span class="lineNum">      54</span>                 :             :    *   ondemand::parser parser;</a>
<a name="55"><span class="lineNum">      55</span>                 :             :    *   document doc = parser.iterate(json);</a>
<a name="56"><span class="lineNum">      56</span>                 :             :    *</a>
<a name="57"><span class="lineNum">      57</span>                 :             :    * It is expected that the content is a valid UTF-8 file, containing a valid JSON document.</a>
<a name="58"><span class="lineNum">      58</span>                 :             :    * Otherwise the iterate method may return an error. In particular, the whole input should be</a>
<a name="59"><span class="lineNum">      59</span>                 :             :    * valid: we do not attempt to tolerate incorrect content either before or after a JSON</a>
<a name="60"><span class="lineNum">      60</span>                 :             :    * document.</a>
<a name="61"><span class="lineNum">      61</span>                 :             :    *</a>
<a name="62"><span class="lineNum">      62</span>                 :             :    * ### IMPORTANT: Validate what you use</a>
<a name="63"><span class="lineNum">      63</span>                 :             :    *</a>
<a name="64"><span class="lineNum">      64</span>                 :             :    * Calling iterate on an invalid JSON document may not immediately trigger an error. The call to</a>
<a name="65"><span class="lineNum">      65</span>                 :             :    * iterate does not parse and validate the whole document.</a>
<a name="66"><span class="lineNum">      66</span>                 :             :    *</a>
<a name="67"><span class="lineNum">      67</span>                 :             :    * ### IMPORTANT: Buffer Lifetime</a>
<a name="68"><span class="lineNum">      68</span>                 :             :    *</a>
<a name="69"><span class="lineNum">      69</span>                 :             :    * Because parsing is done while you iterate, you *must* keep the JSON buffer around at least as</a>
<a name="70"><span class="lineNum">      70</span>                 :             :    * long as the document iteration.</a>
<a name="71"><span class="lineNum">      71</span>                 :             :    *</a>
<a name="72"><span class="lineNum">      72</span>                 :             :    * ### IMPORTANT: Document Lifetime</a>
<a name="73"><span class="lineNum">      73</span>                 :             :    *</a>
<a name="74"><span class="lineNum">      74</span>                 :             :    * Only one iteration at a time can happen per parser, and the parser *must* be kept alive during</a>
<a name="75"><span class="lineNum">      75</span>                 :             :    * iteration to ensure intermediate buffers can be accessed. Any document must be destroyed before</a>
<a name="76"><span class="lineNum">      76</span>                 :             :    * you call parse() again or destroy the parser.</a>
<a name="77"><span class="lineNum">      77</span>                 :             :    *</a>
<a name="78"><span class="lineNum">      78</span>                 :             :    * ### REQUIRED: Buffer Padding</a>
<a name="79"><span class="lineNum">      79</span>                 :             :    *</a>
<a name="80"><span class="lineNum">      80</span>                 :             :    * The buffer must have at least SIMDJSON_PADDING extra allocated bytes. It does not matter what</a>
<a name="81"><span class="lineNum">      81</span>                 :             :    * those bytes are initialized to, as long as they are allocated.</a>
<a name="82"><span class="lineNum">      82</span>                 :             :    *</a>
<a name="83"><span class="lineNum">      83</span>                 :             :    * @param json The JSON to parse.</a>
<a name="84"><span class="lineNum">      84</span>                 :             :    * @param len The length of the JSON.</a>
<a name="85"><span class="lineNum">      85</span>                 :             :    * @param capacity The number of bytes allocated in the JSON (must be at least len+SIMDJSON_PADDING).</a>
<a name="86"><span class="lineNum">      86</span>                 :             :    *</a>
<a name="87"><span class="lineNum">      87</span>                 :             :    * @return The document, or an error:</a>
<a name="88"><span class="lineNum">      88</span>                 :             :    *         - INSUFFICIENT_PADDING if the input has less than SIMDJSON_PADDING extra bytes.</a>
<a name="89"><span class="lineNum">      89</span>                 :             :    *         - MEMALLOC if realloc_if_needed the parser does not have enough capacity, and memory</a>
<a name="90"><span class="lineNum">      90</span>                 :             :    *           allocation fails.</a>
<a name="91"><span class="lineNum">      91</span>                 :             :    *         - EMPTY if the document is all whitespace.</a>
<a name="92"><span class="lineNum">      92</span>                 :             :    *         - UTF8_ERROR if the document is not valid UTF-8.</a>
<a name="93"><span class="lineNum">      93</span>                 :             :    *         - UNESCAPED_CHARS if a string contains control characters that must be escaped</a>
<a name="94"><span class="lineNum">      94</span>                 :             :    *         - UNCLOSED_STRING if there is an unclosed string in the document.</a>
<a name="95"><span class="lineNum">      95</span>                 :             :    */</a>
<a name="96"><span class="lineNum">      96</span>                 :             :   simdjson_warn_unused simdjson_result&lt;document&gt; iterate(padded_string_view json) &amp; noexcept;</a>
<a name="97"><span class="lineNum">      97</span>                 :             :   /** @overload simdjson_result&lt;document&gt; iterate(padded_string_view json) &amp; noexcept */</a>
<a name="98"><span class="lineNum">      98</span>                 :             :   simdjson_warn_unused simdjson_result&lt;document&gt; iterate(const char *json, size_t len, size_t capacity) &amp; noexcept;</a>
<a name="99"><span class="lineNum">      99</span>                 :             :   /** @overload simdjson_result&lt;document&gt; iterate(padded_string_view json) &amp; noexcept */</a>
<a name="100"><span class="lineNum">     100</span>                 :             :   simdjson_warn_unused simdjson_result&lt;document&gt; iterate(const uint8_t *json, size_t len, size_t capacity) &amp; noexcept;</a>
<a name="101"><span class="lineNum">     101</span>                 :             :   /** @overload simdjson_result&lt;document&gt; iterate(padded_string_view json) &amp; noexcept */</a>
<a name="102"><span class="lineNum">     102</span>                 :             :   simdjson_warn_unused simdjson_result&lt;document&gt; iterate(std::string_view json, size_t capacity) &amp; noexcept;</a>
<a name="103"><span class="lineNum">     103</span>                 :             :   /** @overload simdjson_result&lt;document&gt; iterate(padded_string_view json) &amp; noexcept */</a>
<a name="104"><span class="lineNum">     104</span>                 :             :   simdjson_warn_unused simdjson_result&lt;document&gt; iterate(const std::string &amp;json) &amp; noexcept;</a>
<a name="105"><span class="lineNum">     105</span>                 :             :   /** @overload simdjson_result&lt;document&gt; iterate(padded_string_view json) &amp; noexcept */</a>
<a name="106"><span class="lineNum">     106</span>                 :             :   simdjson_warn_unused simdjson_result&lt;document&gt; iterate(const simdjson_result&lt;padded_string&gt; &amp;json) &amp; noexcept;</a>
<a name="107"><span class="lineNum">     107</span>                 :             :   /** @overload simdjson_result&lt;document&gt; iterate(padded_string_view json) &amp; noexcept */</a>
<a name="108"><span class="lineNum">     108</span>                 :             :   simdjson_warn_unused simdjson_result&lt;document&gt; iterate(const simdjson_result&lt;padded_string_view&gt; &amp;json) &amp; noexcept;</a>
<a name="109"><span class="lineNum">     109</span>                 :             :   /** @overload simdjson_result&lt;document&gt; iterate(padded_string_view json) &amp; noexcept */</a>
<a name="110"><span class="lineNum">     110</span>                 :             :   simdjson_warn_unused simdjson_result&lt;document&gt; iterate(padded_string &amp;&amp;json) &amp; noexcept = delete;</a>
<a name="111"><span class="lineNum">     111</span>                 :             : </a>
<a name="112"><span class="lineNum">     112</span>                 :             :   /**</a>
<a name="113"><span class="lineNum">     113</span>                 :             :    * @private</a>
<a name="114"><span class="lineNum">     114</span>                 :             :    *</a>
<a name="115"><span class="lineNum">     115</span>                 :             :    * Start iterating an on-demand JSON document.</a>
<a name="116"><span class="lineNum">     116</span>                 :             :    *</a>
<a name="117"><span class="lineNum">     117</span>                 :             :    *   ondemand::parser parser;</a>
<a name="118"><span class="lineNum">     118</span>                 :             :    *   json_iterator doc = parser.iterate(json);</a>
<a name="119"><span class="lineNum">     119</span>                 :             :    *</a>
<a name="120"><span class="lineNum">     120</span>                 :             :    * ### IMPORTANT: Buffer Lifetime</a>
<a name="121"><span class="lineNum">     121</span>                 :             :    *</a>
<a name="122"><span class="lineNum">     122</span>                 :             :    * Because parsing is done while you iterate, you *must* keep the JSON buffer around at least as</a>
<a name="123"><span class="lineNum">     123</span>                 :             :    * long as the document iteration.</a>
<a name="124"><span class="lineNum">     124</span>                 :             :    *</a>
<a name="125"><span class="lineNum">     125</span>                 :             :    * ### IMPORTANT: Document Lifetime</a>
<a name="126"><span class="lineNum">     126</span>                 :             :    *</a>
<a name="127"><span class="lineNum">     127</span>                 :             :    * Only one iteration at a time can happen per parser, and the parser *must* be kept alive during</a>
<a name="128"><span class="lineNum">     128</span>                 :             :    * iteration to ensure intermediate buffers can be accessed. Any document must be destroyed before</a>
<a name="129"><span class="lineNum">     129</span>                 :             :    * you call parse() again or destroy the parser.</a>
<a name="130"><span class="lineNum">     130</span>                 :             :    *</a>
<a name="131"><span class="lineNum">     131</span>                 :             :    * The ondemand::document instance holds the iterator. The document must remain in scope</a>
<a name="132"><span class="lineNum">     132</span>                 :             :    * while you are accessing instances of ondemand::value, ondemand::object, ondemand::array.</a>
<a name="133"><span class="lineNum">     133</span>                 :             :    *</a>
<a name="134"><span class="lineNum">     134</span>                 :             :    * ### REQUIRED: Buffer Padding</a>
<a name="135"><span class="lineNum">     135</span>                 :             :    *</a>
<a name="136"><span class="lineNum">     136</span>                 :             :    * The buffer must have at least SIMDJSON_PADDING extra allocated bytes. It does not matter what</a>
<a name="137"><span class="lineNum">     137</span>                 :             :    * those bytes are initialized to, as long as they are allocated.</a>
<a name="138"><span class="lineNum">     138</span>                 :             :    *</a>
<a name="139"><span class="lineNum">     139</span>                 :             :    * @param json The JSON to parse.</a>
<a name="140"><span class="lineNum">     140</span>                 :             :    *</a>
<a name="141"><span class="lineNum">     141</span>                 :             :    * @return The iterator, or an error:</a>
<a name="142"><span class="lineNum">     142</span>                 :             :    *         - INSUFFICIENT_PADDING if the input has less than SIMDJSON_PADDING extra bytes.</a>
<a name="143"><span class="lineNum">     143</span>                 :             :    *         - MEMALLOC if realloc_if_needed the parser does not have enough capacity, and memory</a>
<a name="144"><span class="lineNum">     144</span>                 :             :    *           allocation fails.</a>
<a name="145"><span class="lineNum">     145</span>                 :             :    *         - EMPTY if the document is all whitespace.</a>
<a name="146"><span class="lineNum">     146</span>                 :             :    *         - UTF8_ERROR if the document is not valid UTF-8.</a>
<a name="147"><span class="lineNum">     147</span>                 :             :    *         - UNESCAPED_CHARS if a string contains control characters that must be escaped</a>
<a name="148"><span class="lineNum">     148</span>                 :             :    *         - UNCLOSED_STRING if there is an unclosed string in the document.</a>
<a name="149"><span class="lineNum">     149</span>                 :             :    */</a>
<a name="150"><span class="lineNum">     150</span>                 :             :   simdjson_warn_unused simdjson_result&lt;json_iterator&gt; iterate_raw(padded_string_view json) &amp; noexcept;</a>
<a name="151"><span class="lineNum">     151</span>                 :             : </a>
<a name="152"><span class="lineNum">     152</span>                 :             : </a>
<a name="153"><span class="lineNum">     153</span>                 :             :   /**</a>
<a name="154"><span class="lineNum">     154</span>                 :             :    * Parse a buffer containing many JSON documents.</a>
<a name="155"><span class="lineNum">     155</span>                 :             :    *</a>
<a name="156"><span class="lineNum">     156</span>                 :             :    *   auto json = R&quot;({ &quot;foo&quot;: 1 } { &quot;foo&quot;: 2 } { &quot;foo&quot;: 3 } )&quot;_padded;</a>
<a name="157"><span class="lineNum">     157</span>                 :             :    *   ondemand::parser parser;</a>
<a name="158"><span class="lineNum">     158</span>                 :             :    *   ondemand::document_stream docs = parser.iterate_many(json);</a>
<a name="159"><span class="lineNum">     159</span>                 :             :    *   for (auto &amp; doc : docs) {</a>
<a name="160"><span class="lineNum">     160</span>                 :             :    *     std::cout &lt;&lt; doc[&quot;foo&quot;] &lt;&lt; std::endl;</a>
<a name="161"><span class="lineNum">     161</span>                 :             :    *   }</a>
<a name="162"><span class="lineNum">     162</span>                 :             :    *   // Prints 1 2 3</a>
<a name="163"><span class="lineNum">     163</span>                 :             :    *</a>
<a name="164"><span class="lineNum">     164</span>                 :             :    * No copy of the input buffer is made.</a>
<a name="165"><span class="lineNum">     165</span>                 :             :    *</a>
<a name="166"><span class="lineNum">     166</span>                 :             :    * The function is lazy: it may be that no more than one JSON document at a time is parsed.</a>
<a name="167"><span class="lineNum">     167</span>                 :             :    *</a>
<a name="168"><span class="lineNum">     168</span>                 :             :    * The caller is responsabile to ensure that the input string data remains unchanged and is</a>
<a name="169"><span class="lineNum">     169</span>                 :             :    * not deleted during the loop.</a>
<a name="170"><span class="lineNum">     170</span>                 :             :    *</a>
<a name="171"><span class="lineNum">     171</span>                 :             :    * ### Format</a>
<a name="172"><span class="lineNum">     172</span>                 :             :    *</a>
<a name="173"><span class="lineNum">     173</span>                 :             :    * The buffer must contain a series of one or more JSON documents, concatenated into a single</a>
<a name="174"><span class="lineNum">     174</span>                 :             :    * buffer, separated by ASCII whitespace. It effectively parses until it has a fully valid document,</a>
<a name="175"><span class="lineNum">     175</span>                 :             :    * then starts parsing the next document at that point. (It does this with more parallelism and</a>
<a name="176"><span class="lineNum">     176</span>                 :             :    * lookahead than you might think, though.)</a>
<a name="177"><span class="lineNum">     177</span>                 :             :    *</a>
<a name="178"><span class="lineNum">     178</span>                 :             :    * documents that consist of an object or array may omit the whitespace between them, concatenating</a>
<a name="179"><span class="lineNum">     179</span>                 :             :    * with no separator. Documents that consist of a single primitive (i.e. documents that are not</a>
<a name="180"><span class="lineNum">     180</span>                 :             :    * arrays or objects) MUST be separated with ASCII whitespace.</a>
<a name="181"><span class="lineNum">     181</span>                 :             :    *</a>
<a name="182"><span class="lineNum">     182</span>                 :             :    * The characters inside a JSON document, and between JSON documents, must be valid Unicode (UTF-8).</a>
<a name="183"><span class="lineNum">     183</span>                 :             :    *</a>
<a name="184"><span class="lineNum">     184</span>                 :             :    * The documents must not exceed batch_size bytes (by default 1MB) or they will fail to parse.</a>
<a name="185"><span class="lineNum">     185</span>                 :             :    * Setting batch_size to excessively large or excesively small values may impact negatively the</a>
<a name="186"><span class="lineNum">     186</span>                 :             :    * performance.</a>
<a name="187"><span class="lineNum">     187</span>                 :             :    *</a>
<a name="188"><span class="lineNum">     188</span>                 :             :    * ### REQUIRED: Buffer Padding</a>
<a name="189"><span class="lineNum">     189</span>                 :             :    *</a>
<a name="190"><span class="lineNum">     190</span>                 :             :    * The buffer must have at least SIMDJSON_PADDING extra allocated bytes. It does not matter what</a>
<a name="191"><span class="lineNum">     191</span>                 :             :    * those bytes are initialized to, as long as they are allocated.</a>
<a name="192"><span class="lineNum">     192</span>                 :             :    *</a>
<a name="193"><span class="lineNum">     193</span>                 :             :    * ### Threads</a>
<a name="194"><span class="lineNum">     194</span>                 :             :    *</a>
<a name="195"><span class="lineNum">     195</span>                 :             :    * When compiled with SIMDJSON_THREADS_ENABLED, this method will use a single thread under the</a>
<a name="196"><span class="lineNum">     196</span>                 :             :    * hood to do some lookahead.</a>
<a name="197"><span class="lineNum">     197</span>                 :             :    *</a>
<a name="198"><span class="lineNum">     198</span>                 :             :    * ### Parser Capacity</a>
<a name="199"><span class="lineNum">     199</span>                 :             :    *</a>
<a name="200"><span class="lineNum">     200</span>                 :             :    * If the parser's current capacity is less than batch_size, it will allocate enough capacity</a>
<a name="201"><span class="lineNum">     201</span>                 :             :    * to handle it (up to max_capacity).</a>
<a name="202"><span class="lineNum">     202</span>                 :             :    *</a>
<a name="203"><span class="lineNum">     203</span>                 :             :    * @param buf The concatenated JSON to parse.</a>
<a name="204"><span class="lineNum">     204</span>                 :             :    * @param len The length of the concatenated JSON.</a>
<a name="205"><span class="lineNum">     205</span>                 :             :    * @param batch_size The batch size to use. MUST be larger than the largest document. The sweet</a>
<a name="206"><span class="lineNum">     206</span>                 :             :    *                   spot is cache-related: small enough to fit in cache, yet big enough to</a>
<a name="207"><span class="lineNum">     207</span>                 :             :    *                   parse as many documents as possible in one tight loop.</a>
<a name="208"><span class="lineNum">     208</span>                 :             :    *                   Defaults to 10MB, which has been a reasonable sweet spot in our tests.</a>
<a name="209"><span class="lineNum">     209</span>                 :             :    * @return The stream, or an error. An empty input will yield 0 documents rather than an EMPTY error. Errors:</a>
<a name="210"><span class="lineNum">     210</span>                 :             :    *         - MEMALLOC if the parser does not have enough capacity and memory allocation fails</a>
<a name="211"><span class="lineNum">     211</span>                 :             :    *         - CAPACITY if the parser does not have enough capacity and batch_size &gt; max_capacity.</a>
<a name="212"><span class="lineNum">     212</span>                 :             :    *         - other json errors if parsing fails. You should not rely on these errors to always the same for the</a>
<a name="213"><span class="lineNum">     213</span>                 :             :    *           same document: they may vary under runtime dispatch (so they may vary depending on your system and hardware).</a>
<a name="214"><span class="lineNum">     214</span>                 :             :    */</a>
<a name="215"><span class="lineNum">     215</span>                 :             :   inline simdjson_result&lt;document_stream&gt; iterate_many(const uint8_t *buf, size_t len, size_t batch_size = DEFAULT_BATCH_SIZE) noexcept;</a>
<a name="216"><span class="lineNum">     216</span>                 :             :   /** @overload parse_many(const uint8_t *buf, size_t len, size_t batch_size) */</a>
<a name="217"><span class="lineNum">     217</span>                 :             :   inline simdjson_result&lt;document_stream&gt; iterate_many(const char *buf, size_t len, size_t batch_size = DEFAULT_BATCH_SIZE) noexcept;</a>
<a name="218"><span class="lineNum">     218</span>                 :             :   /** @overload parse_many(const uint8_t *buf, size_t len, size_t batch_size) */</a>
<a name="219"><span class="lineNum">     219</span>                 :             :   inline simdjson_result&lt;document_stream&gt; iterate_many(const std::string &amp;s, size_t batch_size = DEFAULT_BATCH_SIZE) noexcept;</a>
<a name="220"><span class="lineNum">     220</span>                 :             :   inline simdjson_result&lt;document_stream&gt; iterate_many(const std::string &amp;&amp;s, size_t batch_size) = delete;// unsafe</a>
<a name="221"><span class="lineNum">     221</span>                 :             :   /** @overload parse_many(const uint8_t *buf, size_t len, size_t batch_size) */</a>
<a name="222"><span class="lineNum">     222</span>                 :             :   inline simdjson_result&lt;document_stream&gt; iterate_many(const padded_string &amp;s, size_t batch_size = DEFAULT_BATCH_SIZE) noexcept;</a>
<a name="223"><span class="lineNum">     223</span>                 :             :   inline simdjson_result&lt;document_stream&gt; iterate_many(const padded_string &amp;&amp;s, size_t batch_size) = delete;// unsafe</a>
<a name="224"><span class="lineNum">     224</span>                 :             : </a>
<a name="225"><span class="lineNum">     225</span>                 :             :   /** @private We do not want to allow implicit conversion from C string to std::string. */</a>
<a name="226"><span class="lineNum">     226</span>                 :             :   simdjson_result&lt;document_stream&gt; iterate_many(const char *buf, size_t batch_size = DEFAULT_BATCH_SIZE) noexcept = delete;</a>
<a name="227"><span class="lineNum">     227</span>                 :             : </a>
<a name="228"><span class="lineNum">     228</span>                 :             :   /** The capacity of this parser (the largest document it can process). */</a>
<a name="229"><span class="lineNum">     229</span>                 :             :   simdjson_really_inline size_t capacity() const noexcept;</a>
<a name="230"><span class="lineNum">     230</span>                 :             :   /** The maximum capacity of this parser (the largest document it is allowed to process). */</a>
<a name="231"><span class="lineNum">     231</span>                 :             :   simdjson_really_inline size_t max_capacity() const noexcept;</a>
<a name="232"><span class="lineNum">     232</span>                 :             :   simdjson_really_inline void set_max_capacity(size_t max_capacity) noexcept;</a>
<a name="233"><span class="lineNum">     233</span>                 :             :   /** The maximum depth of this parser (the most deeply nested objects and arrays it can process). */</a>
<a name="234"><span class="lineNum">     234</span>                 :             :   simdjson_really_inline size_t max_depth() const noexcept;</a>
<a name="235"><span class="lineNum">     235</span>                 :             : </a>
<a name="236"><span class="lineNum">     236</span>                 :             :   /**</a>
<a name="237"><span class="lineNum">     237</span>                 :             :    * Ensure this parser has enough memory to process JSON documents up to `capacity` bytes in length</a>
<a name="238"><span class="lineNum">     238</span>                 :             :    * and `max_depth` depth.</a>
<a name="239"><span class="lineNum">     239</span>                 :             :    *</a>
<a name="240"><span class="lineNum">     240</span>                 :             :    * @param capacity The new capacity.</a>
<a name="241"><span class="lineNum">     241</span>                 :             :    * @param max_depth The new max_depth. Defaults to DEFAULT_MAX_DEPTH.</a>
<a name="242"><span class="lineNum">     242</span>                 :             :    * @return The error, if there is one.</a>
<a name="243"><span class="lineNum">     243</span>                 :             :    */</a>
<a name="244"><span class="lineNum">     244</span>                 :             :   simdjson_warn_unused error_code allocate(size_t capacity, size_t max_depth=DEFAULT_MAX_DEPTH) noexcept;</a>
<a name="245"><span class="lineNum">     245</span>                 :             : </a>
<a name="246"><span class="lineNum">     246</span>                 :             :   #ifdef SIMDJSON_THREADS_ENABLED</a>
<a name="247"><span class="lineNum">     247</span>                 :             :   /**</a>
<a name="248"><span class="lineNum">     248</span>                 :             :    * The parser instance can use threads when they are available to speed up some</a>
<a name="249"><span class="lineNum">     249</span>                 :             :    * operations. It is enabled by default. Changing this attribute will change the</a>
<a name="250"><span class="lineNum">     250</span>                 :             :    * behavior of the parser for future operations.</a>
<a name="251"><span class="lineNum">     251</span>                 :             :    */</a>
<a name="252"><span class="lineNum">     252</span>                 :             :   bool threaded{true};</a>
<a name="253"><span class="lineNum">     253</span>                 :             :   #endif</a>
<a name="254"><span class="lineNum">     254</span>                 :             : </a>
<a name="255"><span class="lineNum">     255</span>                 :             : private:</a>
<a name="256"><span class="lineNum">     256</span>                 :             :   /** @private [for benchmarking access] The implementation to use */</a>
<a name="257"><span class="lineNum">     257</span>                 :             :   std::unique_ptr&lt;internal::dom_parser_implementation&gt; implementation{};</a>
<a name="258"><span class="lineNum">     258</span>                 :             :   size_t _capacity{0};</a>
<a name="259"><span class="lineNum">     259</span>                 :             :   size_t _max_capacity;</a>
<a name="260"><span class="lineNum">     260</span>                 :             :   size_t _max_depth{DEFAULT_MAX_DEPTH};</a>
<a name="261"><span class="lineNum">     261</span>                 :             :   std::unique_ptr&lt;uint8_t[]&gt; string_buf{};</a>
<a name="262"><span class="lineNum">     262</span>                 :             : #ifdef SIMDJSON_DEVELOPMENT_CHECKS</a>
<a name="263"><span class="lineNum">     263</span>                 :             :   std::unique_ptr&lt;token_position[]&gt; start_positions{};</a>
<a name="264"><span class="lineNum">     264</span>                 :             : #endif</a>
<a name="265"><span class="lineNum">     265</span>                 :             : </a>
<a name="266"><span class="lineNum">     266</span>                 :             :   friend class json_iterator;</a>
<a name="267"><span class="lineNum">     267</span>                 :             :   friend class document_stream;</a>
<a name="268"><span class="lineNum">     268</span>                 :             : };</a>
<a name="269"><span class="lineNum">     269</span>                 :             : </a>
<a name="270"><span class="lineNum">     270</span>                 :             : } // namespace ondemand</a>
<a name="271"><span class="lineNum">     271</span>                 :             : } // namespace SIMDJSON_IMPLEMENTATION</a>
<a name="272"><span class="lineNum">     272</span>                 :             : } // namespace simdjson</a>
<a name="273"><span class="lineNum">     273</span>                 :             : </a>
<a name="274"><span class="lineNum">     274</span>                 :             : namespace simdjson {</a>
<a name="275"><span class="lineNum">     275</span>                 :             : </a>
<a name="276"><span class="lineNum">     276</span>                 :             : template&lt;&gt;</a>
<a name="277"><span class="lineNum">     277</span>                 :             : struct simdjson_result&lt;SIMDJSON_IMPLEMENTATION::ondemand::parser&gt; : public SIMDJSON_IMPLEMENTATION::implementation_simdjson_result_base&lt;SIMDJSON_IMPLEMENTATION::ondemand::parser&gt; {</a>
<a name="278"><span class="lineNum">     278</span>                 :             : public:</a>
<a name="279"><span class="lineNum">     279</span>                 :             :   simdjson_really_inline simdjson_result(SIMDJSON_IMPLEMENTATION::ondemand::parser &amp;&amp;value) noexcept; ///&lt; @private</a>
<a name="280"><span class="lineNum">     280</span>                 :             :   simdjson_really_inline simdjson_result(error_code error) noexcept; ///&lt; @private</a>
<a name="281"><span class="lineNum">     281</span>                 :             :   simdjson_really_inline simdjson_result() noexcept = default;</a>
<a name="282"><span class="lineNum">     282</span>                 :             : };</a>
<a name="283"><span class="lineNum">     283</span>                 :             : </a>
<a name="284"><span class="lineNum">     284</span>                 :             : } // namespace simdjson</a>
        </pre>
              </td>
            </tr>
          </table>
          <br>

          <table width="100%" border=0 cellspacing=0 cellpadding=0>
            <tr><td class="ruler"><img src="../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
            <tr><td class="versionInfo">Generated by: <a href="https://github.com/henry2cox/lcov/tree/diffcov_initial" target="_parent">LCOV version 1.0</a></td></tr>
          </table>
          <br>

</body>
</html>
